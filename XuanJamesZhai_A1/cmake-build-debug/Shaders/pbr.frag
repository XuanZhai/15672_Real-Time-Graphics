#version 460
#extension GL_EXT_nonuniform_qualifier : require

layout(location = 0) in vec4 fragColor;
layout(location = 1) in vec3 fragNormal;
layout(location = 2) in vec2 fragTexCoord;
layout(location = 3) in vec3 fragPosition;
layout(location = 4) in mat3 TBN;
layout(location = 7) in vec4 fragPositionLightSpace[10];

layout(location = 0) out vec4 outColor;


layout(set = 0, binding = 0) uniform UniformBufferObject{
    mat4 view;
    mat4 proj;
    vec3 viewPos;
} ubo;

struct UniformLightObject {
/* 0 = sun, 1 = sphere, 2 = spot */
    uint type;
    float angle;
    float strength;
    float radius;
    float power;
    float limit;
    float fov;
    float blend;
    vec3 pos;
    vec3 dir;
    vec3 tint;
    mat4 view;
    mat4 proj;
};

layout(std140, set = 0, binding = 1) uniform UniformLightsObject {
    uint lightSize;
    UniformLightObject lights[10];
} lightObjects;
layout(set = 0, binding = 2) uniform sampler2D depthMap[];

layout(set = 1, binding = 0) uniform sampler2D normalSampler;
layout(set = 1, binding = 1) uniform sampler2D heightSampler;
layout(set = 1, binding = 2) uniform sampler2D albedoSampler;
layout(set = 1, binding = 3) uniform sampler2D roughnessSampler;
layout(set = 1, binding = 4) uniform sampler2D metallicSampler;
layout(set = 2, binding = 0) uniform samplerCube LamcubeSampler;
layout(set = 2, binding = 1) uniform sampler2D brdfSampler;
layout(set = 2, binding = 2) uniform samplerCube cubeSampler[10];

/* Reference: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/ */
vec3 toneMapACES(vec3 color, float exposure){
    const float A = 2.51f;
    const float B = 0.03f;
    const float C = 2.43f;
    const float D = 0.59f;
    const float E = 0.14f;

    color *= exposure;
    return (color * (A * color + B)) / (color * (C * color + D) + E);
}


/* Approximate the Fresnel term using Schlick approximation. */
vec3 SchlickFresnel(float WoH, vec3 F0, float roughness) {
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - WoH, 0.0, 1.0), 5.0);
}


/* Reference: https://learnopengl.com/PBR/IBL/Specular-IBL */
/* Texture sample the Environment LUT. */
vec3 GetEnv(float roughness, vec3 R){
    int lod = int(roughness*10);
    if(lod > 9) lod = 9;
    if(lod < 0) lod = 0;

    return toneMapACES(texture(cubeSampler[lod], R).rgb,1.0);
}


/* Texture sample the BRDF LUT. */
vec2 GetBRDF(float roughness, float NoV){
    /* The LUT Generated by the utility is up side down. */
    vec2 tex = vec2(1-roughness, NoV);
    return texture(brdfSampler, tex).rg;
}


/* Reference: https://learnopengl.com/Advanced-Lighting/Parallax-Mapping */
vec2 ParallaxOcclusionMapping(vec2 texCoords, vec3 viewDir){

    const float minLayers = 8.0;
    const float maxLayers = 32.0;
    float numLayers = mix(maxLayers, minLayers, max(dot(vec3(0.0, 0.0, 1.0), viewDir), 0.0));
    float layerDepth = 1.0 / numLayers;
    float currentLayerDepth = 0.0;
    /* the amount to shift the texture coordinates per layer. */
    vec2 P = viewDir.xy * 0.1;
    vec2 deltaTexCoords = P / numLayers;
    vec2  currentTexCoords     = texCoords;
    float currentDepthMapValue = texture(heightSampler, currentTexCoords).r;

    /* Keep iterating the layers. */
    while(currentLayerDepth < currentDepthMapValue) {
        currentTexCoords -= deltaTexCoords;
        currentDepthMapValue = texture(heightSampler, currentTexCoords).r;
        currentLayerDepth += layerDepth;
    }

    /* Interpolate with the previous layer. */
    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;
    float afterDepth  = currentDepthMapValue - currentLayerDepth;
    float beforeDepth = texture(heightSampler, prevTexCoords).r - currentLayerDepth + layerDepth;

    float weight = afterDepth / (afterDepth - beforeDepth);
    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);

    return clamp(finalTexCoords,0,1);
}


/* Reference: https://learnopengl.com/PBR/Lighting */
/* Compute the D term of the BRDF. */
float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a = roughness*roughness;
    float a2 = a*a;
    float NoH = max(dot(N, H), 0.0);
    float NoH2 = NoH*NoH;

    float num   = a2;
    float denom = (NoH2 * (a2 - 1.0) + 1.0);
    denom = 3.14159 * denom * denom;

    return num / denom;
}


/* Reference: https://learnopengl.com/PBR/Lighting */
/* Compute the GGX using Schlick Approximation. */
float GeometrySchlickGGX(float NoV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num = NoV;
    float denom = NoV * (1.0 - k) + k;

    return num / denom;
}


/* Reference: https://learnopengl.com/PBR/Lighting */
/* Compute the G term */
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NoV = max(dot(N, V), 0.0);
    float NoL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NoV, roughness);
    float ggx1 = GeometrySchlickGGX(NoL, roughness);

    return ggx1 * ggx2;
}


/* Reference: https://learnopengl.com/PBR/IBL/Specular-IBL */
/* Compute the environment light. */
vec3 GetEnvironmentLight(vec3 normal, vec3 view, vec3 R, vec3 albedo, float roughness, float metallic, vec3 F0){

    // Sample pre-filtered map to get the roughness-dependent specular intensity
    float cosTheta = max(dot(R, view), 0.0);
    // Fresnel term
    vec3 F = SchlickFresnel(cosTheta, F0,roughness);

    vec3 kS = F;
    vec3 kD = 1.0 - kS;
    kD = kD * (1-metallic);

    float NoV = max(0.0, min(1.0, dot(normal,view)));
    vec3 EnvColor = GetEnv( roughness, R );
    vec2 EnvBRDF = GetBRDF( roughness, NoV );

    vec3 irradiance = toneMapACES(texture(LamcubeSampler, normal).rgb,1.0);
    vec3 diffuse  = irradiance * albedo;

    vec3 specular = EnvColor * ( F * EnvBRDF.x + EnvBRDF.y );
    return kD * diffuse + specular;
}


/* Reference: https://learnopengl.com/PBR/Lighting */
/* Add light effect for a signle light. */
vec3 PBRLightCalculation(UniformLightObject light, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 albedo, float roughness, float metallic){
    vec3 Lo = vec3(0);
    vec3 L = light.pos - fragPosition;
    float NoL = max(dot(normal, normalize(L)), 0.0);
    float d = 0;

    /* If sun light, direction is the closest within the angle. */
    if(light.type == 0){
        vec3 LoDir = normalize(-light.dir);
        NoL = max(dot(LoDir, normal), 0.0);
        if(abs(NoL) >= 1.0){
            L = LoDir;
        }

        float angle = acos(NoL);

        if(angle <= light.angle/2){
            L = LoDir;
        }
        else{
            L = normalize(normal + LoDir * cos(light.angle/2));
        }
    }
    /* If sphere or spot, choose the closest point on the radius. */
    else if(light.type == 1 || light.type == 2){
        vec3 centerToRay = (dot(L, R) * R) - L;
        vec3 closestPoint = L + centerToRay * clamp(light.radius / length(centerToRay), 0.0,1.0);
        L = normalize(closestPoint);
        d = length(closestPoint);
    }

    /* Half way vector. */
    vec3 H = normalize(view + L);

    float NDF = DistributionGGX(normal, H, roughness);
    float G = GeometrySmith(normal, view, L, roughness);
    vec3  F = SchlickFresnel(max(dot(H, view), 0.0), F0, roughness);

    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;

    vec3 numerator = NDF * G * F;
    float denominator = 4.0 * max(dot(normal, view), 0.0) * max(dot(view, L), 0.0) + 0.0001;
    vec3 specular = numerator / denominator;

    /* If sun light, use the light direction and also no falloff. */
    if(light.type == 0){
        Lo = (kD * albedo/3.14159 + specular) * light.strength * light.tint * NoL;
        Lo = Lo / (Lo + vec3(1.0));
        Lo = pow(Lo, vec3(1.0/2.2));
        return Lo;
    }
    /* Calculate the falloff */
    float falloff = 1 - pow(d/light.limit,4.0);
    falloff = clamp(falloff,0.0,1.0);
    falloff = falloff / (d*d+1);
    vec3 irradiance = light.power * light.tint / (4*3.14159);

    /* If it is a sphere light. */
    if(light.type == 1){
        Lo = (kD * albedo / 3.14159 + specular) * falloff * irradiance * NoL;
    }
    /* If it is a spot light. */
    else if(light.type == 2){
        float LoDir = max(dot(normalize(-light.dir), normalize(L)), 0.0);
        float angle = abs(acos(LoDir));
        float minAngle = abs((light.fov * (1 - light.blend)) / 2);
        float maxAngle = abs(light.fov / 2);
        vec3 maxLo = (kD * albedo / 3.14159 + specular) * falloff * irradiance * NoL;

        if(angle > maxAngle){}
        else if(angle <= minAngle){
            Lo = maxLo;
        }
        else{
            float alpha = (angle - minAngle) / (maxAngle - minAngle);
            Lo = mix(maxLo,vec3(0),alpha);
        }
    }
    /* Gamma Correction. */
    Lo = Lo / (Lo + vec3(1.0));
    Lo = pow(Lo, vec3(1.0/2.2));
    return Lo;
}


/* Check shadow effect for a given light. */
float ShadowCalculation(uint lightIndex, vec3 normal) {
    /* Convert light to NDC space. */
    vec3 fragPositionLightNDC = fragPositionLightSpace[lightIndex].xyz / fragPositionLightSpace[lightIndex].w;

    /* NDC to [0,1] range. */
    fragPositionLightNDC.x = fragPositionLightNDC.x * 0.5 + 0.5;
    fragPositionLightNDC.y = fragPositionLightNDC.y * 0.5 + 0.5;
    /* Current fragment from light's perspective. */
    float currentDepth = fragPositionLightNDC.z;

    /* check whether current frag pos is in shadow using PCF with bias. */
    /* Inspired by: https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping */
    //float bias = max(0.05 * (1.0 - dot(normal, -lightObjects.lights[lightIndex].dir)), 0.005);
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(depthMap[lightIndex], 0);
    for(int x = -1; x <= 1; ++x) {
        for(int y = -1; y <= 1; ++y) {
            float pcfDepth = texture(depthMap[lightIndex], fragPositionLightNDC.xy + vec2(x, y) * texelSize).r;
            shadow += (currentDepth) > pcfDepth ? 0.0 : 1.0;
        }
    }
    shadow /= 9.0;
    return shadow;
}


void main() {

    vec3 viewDir = normalize(fragPosition-ubo.viewPos) ;
    vec2 texCoord = fragTexCoord;
    texCoord.y = 1-texCoord.y;
    texCoord = ParallaxOcclusionMapping(texCoord, normalize(transpose(TBN) * viewDir));

    vec3 normal = texture(normalSampler, texCoord).rgb;
    normal = normal * 2.0 - 1.0;
    normal = normalize(TBN * normal);
    vec3 view = normalize(ubo.viewPos-fragPosition);
    vec3 R = reflect(-view, normal);

    vec3 albedo = texture(albedoSampler, texCoord).xyz * fragColor.xyz;
    float roughness = texture(roughnessSampler, texCoord).r;
    float metallic = texture(metallicSampler, texCoord).r;
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);

    vec3 color = vec3(0);
    //color += GetEnvironmentLight(normal, view, R, albedo,roughness,metallic,F0);

    for(int i = 0; i < lightObjects.lightSize; i++){
       color += ShadowCalculation(i,normal) * PBRLightCalculation(lightObjects.lights[i], normal, view, R, F0, albedo, roughness, metallic);
    }

    outColor = vec4(color,1.0);
}